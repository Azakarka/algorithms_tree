# Disjoint Sparse Table

## Предисловие
Спонсор сегодняшнего топика - tinkoff. 
https://wiki.algocode.ru/index.php?title=Disjoint_Sparse_Table

Не вижу смысла переписывать вполне понятную статью, кроме как для работы offline (то есть скачать этот файл и работать с ним). Так что, если у вас есть интернет советую глянуть статейку, а остальным **Добро Пожаловать!**.

## Постановка задачи

Есть статичный массив нужно посчитать что-то на отрезке, но каждый элемент должен быть единижды. К примеру какой-нибудь F().

P. s. Если у вас операции, которое можно считать на префиксе, можно сделать префиск суммы (сумма, xor) и тд.


## Алгоритм

Дополним массив до степени двойки, чтобы воспользоваться этим чуть позже.

Немного позаимствуем идею из Divide&Conquer или ДО: разделим массив на пополам. Тогда давайте для каждого элемента l слева от середины m посчитаем F() с m по l, то есть на суффиксе левого массива, а для каждого элемента r справа от середины посчитаем gcd с m + 1 по r, то есть на префиксе правого массива. Теперь сохраним это куда-нибудь и запустимся рекурсивно от наших подмассивчиков.

Тогда пусть S[k][i] это ответ на k - ом уровне для i. Тогда как делать запросы?

Посмотрим на середину массива, у нас есть два случая

1) середина попадает на отрезок [l, r] => ответ: F(S[k][l], S[k][r]).

2) середина справа/слева => запустимся соотвественно справа/слева и возьмем ответ от него.

Да, чем-то напоминает ДО, практически это оно и есть. Что ж, асимптотика log, где наша обещанная единица? 

** BIT OPERATIONS JOIN THE GAME** 


Воспользуемся тем, что размер массива - степень двойки. Рассмотрим двоичное представление l и r. Тогда утверждается, что если их текущии биты равны, то они в одной половине, иначе в разных. Тогда нам всего лишь нужно найти первый несовпадающий бит, это и будет наш k и взять соответсвенно F(S[k][l], S[k][r]) в ответ.

Не правда ли гениально?


## КОД

```

// забилдили

int l, r;

int k = __builtin_ctz(l ^ r);

cout << f(S[k][l], S[k][r])
```

Не нужно пугаться __builtin_ctz

На кфа есть небольшой блог, где эта штука тоже есть https://codeforces.com/blog/entry/15643

Но по сути __builtin_ctz (count trailing zeros, то есть дословно посчитать кол-во нулей сконца, то есть с самого маленького битика). 

Соответсвенно если брать, что S[0] - ответ для самого первого деления получается очень красивый код практически в пару строчек.

P. s. в статье выше предлаегается предподсчет для всех l ^ r, что в приниципе неплохо, но если будете пользоваться моим кодом юзаните 
```
#pragma GCC target("popcnt")
```
P. s. 2 builtin работает не за O(1), так что предподсчет вполне даже рационален.