# Алгоритм МО

## Предисловие
Очень интересный алоритм который позволяет из O(n ^ 2) сделать O(n * sqrt(n)) всего лишь за одну сортировку.


## Постановка задачи
Дан массив из n элеметов и q запросов вида посчитайте f(l, r) на соответсвенно отрезке с l по r, где 

f(l, r) = сумма по всем значениям (сколько число встречается на отрезке) ^ 2 * само число

к примеру, задан массив [1, 2, 3, 1]
Тогда f от всего массива это

(2 ^ 2 * 1) + (1 ^ 2 * 2) + (1 ^ 2 * 3) = 9

## Алгоритм

Давайте разобьем левые границы наших запросов на блоки размера K, то есть запросы у которых l / k равны будут находиться в одном блоке. А внутри одного блока посортим правые границы.

Теперь после сортировки просто будем втупую идти по запросам и отвечать на них.

Для этого обычно вводятся функции add() и del().

## КОД
```
add (int val)
	count[val]++
	ans = ...пересчет...
	
del (int val)
	count[val]--;
	ans = ...пересчет...
	

comparator () 
	if l1 / k == l2 / k
		return r1 < r2
	else 
		return l1 / k < l2 / k // ну или просто l1 < l2
		

main()
	q[]
	sort(q, comparator)
	l = 0, r = -1 // пустой отрезок
	for i = 0 ... q.size()
		now = q[i]
		while (r < now.r) add(++r)
		while (now.l < l) add(--l)
		while (now.r < r) del(r--)
		while (l < now.l) del(l++)
		ans[now.ind] = cur_ans
```

 Обратите внимание, что важно, чтобы сначало шло добавление, а только потом удаление, потому что иначе мы можем выйти в отрицательный отрезок  и не понятно, что там случится...
 
 ## Асимптотика

А какой k брать и почему это будет быстро?

*Нет, ответ не sqrt(n), ответ - надо считать.*

При каком-то запросе граница l пройдет максимум k расстояния, потому что мы смотрим один блок, а в блоке максимальная разница между l = k.

А также в каждом блоке граница r может пройти O(n).

Тогда итоговая асимтотика:

q * k + n / k (кол-во блоков) * n

Если взять n = q, получится nk + (n ^ 2) / k

Нам нужно подобрать такое k, чтобы это значение было минимальным, утверждается, что в сумме это достигается, когда слагаемые равны, то есть

nk = (n ^ 2) / k, а отсюда

k ^ 2 =  n

k = sqrt(n)

Подставляем в нашу асимптотику и получаем:

n * sqrt(n) + n * sqrt(n) = O(n * sqrt(n))


## Послесловие

Теперь почему я сказал, что надо считать. Потому, что асимптотика не всегда n * k + (n ^ 2) / k, она может быть n * k * log + (n ^ 2) / k или еще какая-нибудь.

А вообще, в олимпиадной тусовке принято брать k как константу, а не считать ее каждый раз как sqrt(n), лично у обычно беру k как 330, или 400.

Также, если у вас тлится задача, попробуйте поиграться с значением k, зачастую разные константы, не сильно отличающиеся друг от друга, дают колоссальный эффект.