# 3D MO

## Предисловие
Не бойтесь геомы тут не будет и лютых алгоритмов тоже. 3D MO, как свой двухмерный друг очень маленький, легко пишется и понимается.

Что такое 3D? 3D обозначает три параметра t, l, r. О них поговорим в самом алгоритме, а пока 

**3D MO - MO с изменениями**

## Постановка задачи
Есть массив из n чисел и q запросов двух видов:

1) l, r, x, y - сколько чисел с l по r лежат в промежутке с x по y
2) ind, val - теперь a[ind] = val

(Лично я решал эту задачу через Merge_Sort_Tree + декартач, но вот можно и МО загнать)

## Алгоритм

Зададим каждый запрос типа get тремя параметрами: t, l, r, где t - сколько запрос на изменение было до этого, а l и r соответственно сам отрезок.

Тогда отсортим запросы по (t / k, l / k, r) и будем просто втупую перебирать, то есть доводить текущую версию до нужной нам или ее откатывать, также доводить до нужного нам l и r.

## КОД

```
add()

del()


chgs[], a[], q[]

sort(q)

t = 0, l = 0, r = -1
for i = 0... n - 1
	// здесь 4 вайла как в МО
	
	while t < q[i].t
		chgs.push(ind, a[ind])
		// надо еще пересчитать ans
		t++
	while (q[i].t < t)
		p = chgs.pop_back()
		a[p.f] = p.s
		// пересчет ans
		t--;
	ans[q[i].ind] = cur_ans
```


## Асимптотика

Посчитаем сколько изменится каждый. 

t: q * k
l: q * k, то есть для каждого запроса он пройдет максимум k
r: (n / k) * (t / k) * N, так как в каждом блоке r может пройти N

Итого, если взять n = t = q, получаем:

nk + ((n / k) ^ 2) * n

Отсюда k ^ 3 = n ^ 2

k = n ^ (2 / 3)

Поставляем в асимптотику, получаем:

n ^ (5 / 3) + n ^ (5 / 3) = O(n ^ (5 / 3))


Да, близко к квадрату, но все же не он.