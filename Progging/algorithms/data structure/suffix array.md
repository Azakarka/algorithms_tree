# СУФФИКСНЫЙ МАССИВ

## предисловие
Начнем с вопросов "что это такое" и "зачем он вообще нужен?". Суффиксный массив - такая структура данных, которая, с предподсчетом за nlog, выдаст массив отсорченных суффиксов или минимальный сдвиг строки, или позволит сранивать две строки за O(log(len)), но если они длины степени двойки то за O(1).

Вообще алгос очень простой в понимании и написании, но очень прикольный, наверно, как Фенвик.

А еще, я буду объяснять не классическое решение, а полегче за O(n * log^2).


## постановка задачи
Классическая постановка следующая: 
Есть строка s длины n, нужно вывести перестановку a длины n такую, что
s[a[0]...n] <= s[a[1]...n] <= s[a[2] <= n], где s[i...j] - подстрока с i-ого по j-ый элемент. То есть, по сути нужно отсортить все суффиксы строки.

## алгоритм

В алгоритме используются подстроки s[i...j], где i >= j. Такие подстроки называются *циклическими*.  Цисклическая подстрока s[i...j], где i >= j, равна подстроке s[i...n] + s[1...j].

Для начала скажу, что на самом деле алгоритм сортит не суффиксы строки, а все циклические подстроки длины h, где 2 ^ h >= n, но потом скажу, как это свести к задачи сверху.


Введем массив *p* и число h (2^h >= n), тогда алгоритм состоит из h итераций. На i-ой итерации *p* будет предствалять из себя отсорченный массив всех цикличесиких подстрок длины 2^i. В *p*, конечно, будут хранится не сами подстроки, а индексы их начал. После каждой итерации мы будем пересчитать *p* и в итоге получим конечный ответ.

Введем теперь вспомогательный массив *c*. *с*  - это как бы массив рангов, то есть подстроки с одинаковым рангом равны (в обратную сторону тоже), а также, чем больше ранг, тем лексиграфически больше строка с этим рангом. *с* мы тоже будем пересчитывать на каждой итерации. 

**Нулевая итерации**, база алгоритма. Пока не буду вдаваться в подробности реализации, поэтому максимально просто. Изначально p - массив отсорченных подстрок строки s длины 1, а *c*, соотвественно, их ранги. 

Пример:
abacaba (классическая строка)
p = [0, 2, 4, 6, 1, 5, 3]
или, к примеру, *p* может быть таким:
p = [2, 4, 0, 6, 5, 1, 3],
то есть порядок одинаковых строк не важен.
но *c* задается однозначно:
с = [0, 1, 0, 2, 0, 1, 0]

вот для удобства
s = abacaba
c = 0102010


База основана, теперь к переходам. После i-ой итерации мы имеем массивы *p* и *c* для подстрок длины 2^i. Теперь создадим какой-то массив троек *a*, где a[i] = {c[i], c[(i + 2 ^ (i - 1)) % n], i}.
По сути мы задаем нашу новую строку длины 2^i, двумя строками размерами 2^(i-1). Сортим *а* и получаем новый массив *p*, ну, и *c* соответственно. Почему мы получаем *p*? Потому, что подстроки вдвое меньшей длины однозначно задают новую строку. Если они равны, то оба их числа равны, если одна меньше, то у нее число первее должно быть меньше и тд.

Хоба, после всех этих танцев мы получаем массив p с циклическими подстроками длины 2^h, готово

### свод задачи

Теперь как-то из получившегося массива *p* нужно получить отсорченные суффиксы. А вот очень просто: припишем какой-то знак #, меньший всего алфавита в конец и все. 

Почему это работает? Возьмем для удобства массивы *a*(отсорченные суффиксы) и *b*(наш конечный *p*). Рассмотрим две какие-то циклические подстроки длины 2^h. Пусть первая будет меньшей длины (всм меньшее расстояние до #). Тогда если первая меньше второй до знака #, то она будет первее в обоих массивах. Если больше до знака #, то и больше будет в обоих массивах. А если первая больше второй из-за знака #, то есть до этого они были равными, то она будет меньше второй также в обоих массивах, так как префикс всегда меньше самой строки.


## асимптотика

Всего у нас logn итераций, на каждой мы делаем сорт за еще nlog, итого O(n * log^2). 

В алгоритме за O(n * log), просто сорт делается немного поумнее, поэтому он работает за n.


##  КОД	
```
// нулевая итерация

vector<vector<int>> cnt(sz);
    for(int i = 0; i < n; i++)
        cnt[s[i] - 'a'].emplace_back(i);
	// да это сортировка подсчетом
    int timer = 0; // ранг
    int ind = 0; // номер числа в p
    for(int i = 0; i < sz; i++){
        for(int to : cnt[i])
            p[ind++] = to, c[to] = timer;
        timer += (!cnt[i].empty());
    }

// начало итераций

    for(int h = 0; (1 << h) < n; h++){
        vector<tuple<int,int,int>> a;
        for(int i = 0; i < n; i++)
            a.emplace_back(c[i], c[(i + (1 << (h))) % n], i);
        sort(all(a));
        int loc = 0;
        for(int i = 0; i < n; i++){
            auto[fst, sec, ind] = a[i];
            if(i > 0 && make_pair(fst, sec) != make_pair(get<0>(a[i-1]),get<1>(a[i-1])))
                loc++;
			// вот этот страшный if, означает, что строки не равны, поэтому rank++
			
            p[i] = ind, c[ind] = loc;
        }
    }

```


## Задачи

Честно говоря, я сам решал это на интенсиве по рукоду 2021 года, так что ссылок не будет.

### Сравнение строк
Асимптотика похуже чем плюсы конечно, но можно за лог сравнить две строки. Просто идти и сравнивать ранги их подстрок. Для этого я хранил каждую свою итерацию как массив c[h][n] и p[h][n].


### поиск наименьшего лексиграфического сдвига
Просто выводим p[0]
