==TODO== Задачи на точку и отрезки и точки и отрезок. Еще kый ноль.





# Задачи

## отрезки и точки

Даны n отрезков и q запросов, каждый запрос описывается множетсвом точек. Нужно ответить сколько отрезков таких, что он содержит хотя бы одну точку.

#### Решение оффлайн за nlog:
Решим задачу от обратного: найти кол-во таких отрезков, которое не содержит ни одну точку.
Тогда пусть у нас есть две точки X(i) и X(i+ 1).
Тогда все отрезки которые лежат строго с [X(i) + 1; X(i + 1) - 1] берутся в ответ. 
Тогда кинем все такие отрезки по всем запросам в какой-то масси и отсортим по левой границе. 

Сделаем массив a. Тогда a[i] - кол-во начальных отрезков с правой границей ровное i. 

Теперь будем перебирать отрезки запроса по увеличению левой границы и постепенно удалять начальные отрезки, чьи левые границы левее нашей текущей. Тогда ответ для текущего отрезка будет сумма в массиве c l по r. Можно легко доказать, что это сумма на префиксе до r. 

Так как массив a изменяется нужно использовать ДО или Дерево Фенвика, которое кст легче, так как нам нужна сумма на префиксе.

**КОД**:
```
vector<prek> b;
    for (int i = 0; i < m; i++) {
        int k;
        cin >> k;
        vector<int> c(k + 2, 0);
        c[k + 1] = 1e6 + 10;
        for (int j = 0; j < k; j++) {
            cin >> c[j + 1];
        }
        for (int j = 1; j < k + 2; j++) {
            if (c[j - 1] + 1 > c[j] - 1)continue;
            b.emplace_back(c[j - 1] + 1, c[j] - 1, i);
        }
    }
    sort(all(a), comp2);
    sort(all(b), comp);
    for (int i = 0; i < n; i++) {
        add(a[i].r, 1); // add segment
    }
    int ind = 0;
    vector<int> ans(m, 0);
    for (auto x : b) {
        while (ind < n && a[ind].l < x.l) {
            add(a[ind].r, -1); // delete segment
            ind++;
        }
        ans[x.ind] += get(x.r);
    }
```
b - массив отрезков запроса
a - массив начальных отрезков
add - добавление в Фенвике
get - сумма на префиксе


#### Решение онлайн за n * (log ^ 2):

Будем в вершине ДО хранить отсортированный список правых границ таких, что их левая граница лежит в отрезке этой вершины до.

Просто запустим ДО от отрезка между точками из предыдущего разбора и посчитаем за O(log ^ 2). То есть за log мы спускаемся и за log находим бинпоиском ответ в вершине. 

