Алгоритм Хопкрофта-Карпа ищет паросочетание за  **O(sqrt(V) * E)**
на самом деле круто.

Только сегодня о нем услышал, хотя еще 4 месяца назад прорешал весь парсоч. Алгоритм не рассказывают скорее всего из-за того, что на него просто нет задач, но ускорения кода примерно в 100 раз, думаю сильно сказывается, когда, к примеру, нужно пихнуть еще какую-то константу. Крч знать не будет лишним.


Сразу скажу, что без картинки я сам нифига не понял, так что вот ссылочки там есть и картинки и объяснения если что.

https://www.youtube.com/watch?v=lM5eIpF0xjA&ab_channel=JoromyBouKhalil - видео на которое я буду ссылаться

https://brilliant.org/wiki/hopcroft-karp/ - статья из которой я понял алгоритм
(русская вики, кст, тоже классная)


# Идея

## Постановка задачи
Есть двудольный граф G, с долями U и V.

Нужно найти максимальное паросочетание M.

## алгоритм

Алгоритм похож на Куна: он ищет удлиняющиеся цепи и перестраивает парсоч соответственно. Алгоритм:

1) посмотрим все свободные вершины из U, запустим от них БФС. 
2) Будем идти по БФСу пока не найдем какую-то свободную вершину из V.
3) Теперь с помощью дфса давайте будет подниматься по дереву бфса от найденной вершины из V до соответсвенно ее отца(свободной вершины из U) и будем удалять все вершины на пути. Запомним этот путь, удалим его из дерева бфса и инвертируем его после данной итерации.
4) Идем так пока не кончатся вершины. Инвертируем запомненные пути, начинаем с пункта 1.

Повторяем процесс пока не кончатся удлиняющиеся пути.

## Асимптотика
За одну итерацию мы сделаем БФС по всему графу, соответственно одна итерация скушает E времени. Главный вопрос: почему итерация всего sqrt(V)?

Все очень просто, глвное знать один важный факт. *После каждой итерации длина кратчайшего удлиняющегося пути будет больше хотя бы на один*. 

**ДОКАЗАТЕЛЬСТВО**

Не знаю как это строго доказать, но если примерно можно по индукции. Пусть у нас сейчас длина кратчайшего такого пути будет k, докажем что после итерации длина кратчайшего будет не меньше k + 1. Ну во-первых благодаря БФСу можно с уверенностью сказать, что если есть какие-то удлиняющиеся пути длины k и m, где m > k, то опять таки благодаря БФСу, путь длины k скушает свободную вершинку раньше, потому что путем длины k в БФСе мы ее найдем раньше, а потом удалим.

Рассмотрим какую-то вершину v0, которая в начале итерации могла бы найти удлиняющуюся цепь, но вот свободные вершинки уже скушали дригие цепи, и на конец итерации свободных не осталось. Эта цепь длины k, и она не увеличилась. Чтобы доказать утверждение выше, нужно доказать, что она в последствии не станет удлиняющейся цепью. Нужно заметить то, что когда мы инвертируем какой-то удлиняющийся путь, занятые вершины не меняются, их кол-во растет. То есть вершины которые мы могли бы взять в начале итерации, и которые были взять под конец итерации никогда не станут свободными, соответсвенно для вершины v0 на глуюбине k не будет свободных вершин, для чего ей придется идти ниже, а значит путь будет увеличен хотя бы на 1. Ух, вроде доказал.

**КОНЕЦ АДА**

*Так сколько же по итогу будеи итераций?*. Давайте сделаем sqrt(V) итераций. 
Вычтем из максимального парсоча(M) текущий(M'). (Вычтем значит сделаем какой-то граф G' такой, что ребра которые имеются и в M и в M' мы не берем, как и ребра, который не используются ни там, ни там.) Скажем для удобства, что красные ребра - ребра из M, а синие из M'. Тогда что из себя представляет G'? Ну, если ты читал алгоритм Куна, то G' состоит из каких-то цепей и циклов. Ну давайте удалим все компоненты связанности четной длины, нам на них все равно: они преисполнились. Рассмотрим оставшихся ребят. Мы сделали корень итераций, мин длина удлиняюшейся цепи корень. Соответсвенно цепей тоже корень. А значит нам нужно найти еще корень цепей.

Конечная асимптотика O(sqrt(V) * E) операций

```
int dfs(int v, int bit){ // возвращает свободную вершину из U
    
	used[bit][v] = timer;
    if (bit == 0 && taken[bit][v] == -1)return v; // нашли
    
	for(int to : gr2[bit][v]){
        if(used[bit ^ 1][to] == timer)continue;
        int loc = dfs(to, bit ^ 1);
        
		if(loc != -1){
            if(bit == 1){ // инвертирование путя
                taken[0][to] = v;
                taken[1][v] = to;
            }
            return loc;
        }
    
	}
    return -1;
}

void solve(){
    deque<pii> bfs;
	// инициальзиция
    timer++;
    for(int i : {0, 1})for(int j = 0; j < max_n; j++)gr2[i][j].clear();
    for(int i : {0, 1})for(int j = 0; j < max_n; j++)dist[i][j] = -1;
    for(int i = 0; i < n; i++)if(taken[0][i] == -1)bfs.emplace_back(i, 0), used[0][i] = timer, dist[0][i] = 0;
    
	int fin = 1e9 + 7; // длина минимального пути
    deque<int> deq;
    while(!bfs.empty()){
        auto[v, bit] = bfs.front();
        bfs.pop_front();
		// мы идем только до глубины кратчайшего удлиняющегося пути
        if(dist[bit][v] > fin)break;
        if(dist[bit][v] == fin){
            if(bit == 1 && taken[bit][v] == -1)deq.emplace_back(v);
            continue;
        }
		
        for(int to : gr[bit][v]){
            // на нечетной глубине мы можем пойти только по взятому ребру
			if(bit == 1 && to != taken[bit][v])continue;
            
			if(used[bit ^ 1][to] == timer){
                if(dist[bit ^ 1][to] > dist[bit][v])gr2[bit ^ 1][to].emplace_back(v);
                continue;
            }
			
            gr2[bit ^ 1][to].emplace_back(v); // чтобы потом по dfs'у идти
            used[bit ^ 1][to] = timer;
            dist[bit ^ 1][to] = dist[bit][v] + 1;
            if(bit == 0 && taken[bit ^ 1][to] == -1)
                fin = dist[bit][v] + 1; // нахождение наименьшей глубины
            bfs.emplace_back(to, bit ^ 1);
        }
    }
    timer++;
    for(int v : deq){
        int ind = dfs(v, 1);
        if(ind == -1)continue;
    }
}
```
ну видно что асимтотически sqrt(n) * m
Но константы конечно не оч
