Наконец-то добрались руки и до Тарьяна. 

На самом деле алгоритм простой и легко пишется, хотя казалось бы асимптотика просто сказочная. (*спойлер* время работы O(n * *alpha*))

# Идея
Запустим обычный дфс. На выходе из вершины будем кидать ее в dsu с отцом.

Пусть мы сейчас находимся в вершине которая является одним и запросов. 

1) Тогда мы либо его не посетили -> ничего не делаем.

2) Посетили  -> ответом будет dsu для второй вершины. 

**Важно**, что мы сначала заходим в сына, потом его кидаем в dsu, а потом после всех уже смотрим на концы в нашей вершине.



# Доказательство

*Я доказательство не читал, так что буду своими словами.*

Рассмотрим два варианта:

1) v предок u -> когда мы будем смотреть концы u будет в dsu с v *ok*


2) не предок соответсвенно. Пусть l - lca(v, u), тогда, когда мы придем в l, мы сначала пойдем в v (так взяли), обойдем его поддерево, кинем его в dsu. Потом дойдем до u и v будет лежать в dsu с l. Понятно, что не может взяться вершина ниже l, а выше не может потому, что после того как мы рассмотрим поддерево l, мы его уже не будем рассматривать, соответсвенно для данной пары ответ не изменится. 


# CODE


``` 
int find(int x) {
    if (p[x] == x)return x;
    return p[x] = find(p[x]);
}
 
void merge(int x, int y) {
    int k = x;
    x = find(x);
    y = find(y);
    if (x != y) {
        if (rank[x] < rank[y])swap(x, y);
        p[y] = x;
        rank[x] += rank[y];
        dsu[x] = k;
    }
}
 
void dfs(int v, int par = 0) {
    for (int to : a[v]) {
        if (par ==to)continue;
        dfs(to);
        merge(v, to);
    }
    for (int to : que[v]) {
		if(used[to] == 1){
			//do
		}
    }
	used[v] = 1;
}
```

## А еще есть оптимизация по памяти
#### так как кто-то слишком много ест(это *рекурсия*)
```int find(int x) {
    int k = x;
    while (p[k] != k) k = p[k];
    while (p[x] != x) {
        p[x] = k;
        x = p[x];
    }
    return k;
}
 
void merge(int x, int y) {
    int k = x;
    x = find(x);
    y = find(y);
    if (x != y) {
        if (rank[x] < rank[y])swap(x, y);
        p[y] = x;
        ranki[x] += ranki[y];
        dsu[x] = k;
    }
}


deque<int> deq;
    deq.emplace_back(0);
    while (!deq.empty()) {
        int v = deq.front();
        if (a[v].empty() || used[a[v][0]] == 1) {
            used[v] = 1;
            for (auto to : que[v]) {
                if (used[to] == 1)
                    sum += dsu[find(to)];
            }
            merge(par[v], v);
            deq.pop_front();
        } else {
            for (int to : a[v]) {
                deq.push_front(to);
            }
        }
    }
```
# Асимптотика
Код работает за O(n * *alpha*), где *alpha* - обратная Аккермана, кушает O(n) памяти.