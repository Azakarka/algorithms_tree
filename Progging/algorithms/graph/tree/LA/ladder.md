Предподсчет за n, ответ за O(logn), может быть оптимизирована двоичными прыжками до O(1) но и **памяти сожрет в log раз больше**. 



Сам алгоритм. Мы посчитали все длинные пути для вершины и каждый список удвоили. Для каждой вершины также храним где она лежит и ее индекс там. 

Начнем с нашей вершины. Пусть x на сколько надо прыгнуть. Если k меньше кол-ва оставшихся элементов мы просто берем ее, иначе:

Пусть веришина v это первая не входящая в нашу лестницу, тогда раз мы не взяли ее в наш список значит у нее есть какой-то сын u у когорого основная лестница не меньше нашей дополненной, а значит ее размер как минимум больше в два раза, что и дает log в итоге. Потому что на каждом шагу размер лестницы увеличивается минимум в 2 раза.