# 1 D 1 D оптимизация

Опять какая-то идейная китайская фигня # атыинепротив.

## Постановка задачи
Есть какой-то одномерный массив, что-то в нем надо посчитать, в общем не важно, главное что выполняется условие opt[i] <= opt[i + 1]

Ну, к примеру, какая-нибудь такая динамика:

dp[i] = min(dp[j] + f(j + 1 ... i)) | где f(l, r) соотвественно какое-то значение на отрезке.

Тупняк соотвественно работает за O(n ^ 2)

## Алгоритм

Идея держится на двух концептах: 
1) Если мы знаем opt[i], мы можем за O(1) восстановить ответ для dp[i]
2) Как уже было сказано opt[i] <= opt[i + 1]

*Будем считать массив opt вперед.*

Пусть мы посчитали для какого-то i -1 префикса, тогда текущий массив opt'ов выглядит как-то так:

![[opts.png]]

То есть мы вперед уже пересчитали все opt для индексов (i .. n - 1), возможно какие-то индексы были настолько плохие, что они в оптах вообще не встречались, возможно, все вообще будут одинаковые, главное лишь то, что выолняется монотонность. Назовем последовательность одинаковых значений в массиве opt блоком.

*Хорошо, мы посчитали для префикса i - 1, как пересчитать для i-ого?*

Будем идти с конца и релаксировать ответ для всех начал блоков. Зададим текущий блок с началом l. Тогда есть два варианта событий:

1) dp[l] прорелаксирован, то есть стал лучше, а значит нужно обновить opt[l], а соответсвенно и все элементы в блоке по правилу
2) dp[l] не улучился => нужно найти какой-то первый индекс k в блоке, у которого ответ улучшится и с k начать наш блок с значением i. Этот шаг можно сделать с помощью бинпоиска.

В итоге после всех итераций мы получим полноценный массив opt'ов и сможем легко пересчитать динамику.



## КОД

``` 
dp[], opt[], blocks[];

block.push(1)
for i = 0 ... n - 1 
	int ind = n;
	while (blocks != empty && !relax(blocks.back()))
		ind = block.back()
		blocks.pop_back()
	if (blocks != empty)
		ind = find(blocks.back(), n - 1)
	blocks.push(ind)
```

Подробные детали реализации не очень интересны, так как алгоритм достаточно простой.


## Асимптотика

Каждый индекс один раз добавляется и удаляется из массив блоков + бинпоиск, так что в итоге O(nlog)