# Разделяй и Властвуй

## Предисловие

Алгоритм "Разделяй и Властвуй" на самом деле используется далеко не только в динамике. Основная идея алгоритма - брать середину чего-то, считать ответ только для правой, только для левой половин, и потом рассматривать пересечения. В ДПшке идея примерно такая же, так что погнали!


## Постановка задачи
 Вводится массив положительных чисел длины n. Нужно разбить его на K блоков, чтобы сумма квадратов суммы в блоке была минимальна.
 
 ## Тупняк
 Какое здесь тривиальное решение? 
 
 Пусть dp[k][i] - ответ для i-ого префикса, если мы разбили его на k блоков.
 
 Тогда пересчет будет таким:
 
dp[k][i] = min(dp[k - 1][j] + sum(j + 1, i) ^ 2) | j < i

Итоговая асимптотика O(n * K)

## Алгоритм
Введем вспомогательный массив opt, где

opt[k][i] - тот самый оптимальный j из пересчета для dp[k][i].

Тогда, *основная идея алгоритма в том, что opt[k][i] <= opt[k][i + 1]*

То есть, если  мы пихаем еще одно число в конец, то левая граница последнего блока смещается вправо.

Думаю, это достаточно интуитивно понятно.

Заметим также, что одинаковые слои друг от друга не зависят и можно считать для каждого независимо.

*Тогда, пусть мы посчитали для k - 1 слоя и хотим посчитать для k-ого.*

Запустимся из середины отрезка  и посчитаем ответ для dp[k][m], заодно и opt[k][m]. Тогда, по правилу, написаному выше opt всех чисел слева будет <= opt[k][m], а opt всех чисел справа соотвественно >= opt[k][m].

Тогда запустим рекурсию от половин с соответсвующими ограничениями и втупую посчитаем ответ.

## КОД

```
void solve (a[], l, r, optl, optr) {

m = (l + r) / 2;

dp[k][m] = ...пересчет втупую...
opt[k][m] = ...пересчет втупую...


solve(a, l, m, optl, opt[k][m]);
solve(a, m + 1, r, opt[k][m], r);

}
```
Код действительно маленький и простой, почему же он будет быстро работать?

## Асимптотика

Асимптотику можно задать такой простенькой формулкой.

T(n) = O(n) + 2 * (n / 2)

Тогда это будет

n + 2 ( n / 2 + 2 ( n / 4  + 2 ( n / 8 ) ) )...
И так log слоев и того:

n + n + n ... + n = nlog

Действительно, получается O(nlog) на слой, а так как слоев K, то еще и K припишем в конец.

**Итого: O(k * nlog)**

