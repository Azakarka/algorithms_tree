# O(n^2) вместо O(n^3) в ДП по поддеревьям


Значит оптимизация очень простая, но оптимизирует алгос в n раз. 

### Описание задачи
Примеры будут ниже.
Пусть у нас будет какая-нибудь задача, где надо перебирать что-то у всех наших сыновей и потом записать лучшее в дп для текущей вершины. В дп пусть будет хранится ответ для n состояний. Получается, чтобы найти лучший ответ нужно перебрать все n^2 состояний, а запускается это в n вершинах, из чего выходит алгос за O(n ^ 3)


### Примеры
Чтобы было понятней ща будет пару примеров.

1) Дано дерево, с взвешенными вершинами. Нужно разбить это дерево на не более k компонент связанностей, так чтобы сумма значений в вершинах, взятых в одну из компонент была максимальна. Другими словами, можно удалить некоторые кол-во вершин из дерева, чтобы кол-во комп. связ. было не более k и сумма оставшихся вершин максимальна. n, k <= 5000

Решение: сделаем dp[v][C] - максимальная сумма, если в v-ом поддереве сделать ровно C компонент. Тогда как значит пересчитывать. Возьмем наших сыновей и визуально сделаем из них матрицу M, где M[i] = dp[to_i]. Тогда посчитать dp[v][C] можно следующим образом: нужно взять по индексу из каждой строчки M, так чтобы сумма индексов=C, а сумма чисел в индексах была максимальна. Значит пересчитать это за C^2 можно следующий образом: сделаем какой-то dp2 и будет итерироваться по сыновьям. Изначально dp2 равно dp от первого сына. Теперь переход будет следующим: переберем за C индекс у dp2 и за С индекс у dp[to_i] и пересчитаем dp2. Выходит решение за O(n * C^2)

2) Вот еще задача, тут и разбор есть с лучшим объяснением что да как 
https://codeforces.com/problemset/problem/581/F


### сама оптимизация 
оказывается, оказывается, если идти не до C, а до sz[v], то решение будет за квадрат. Почему sz[v]? Потому, что мы перебираем на сколько компонент разобьем, но мы ведь не можем разбить на больше, чем у нас есть вершин. То есть псевокод будет таким:
```
int sum = 0;
for(int to : gr[v]){
	for(int i = 0; i <= sum; i++)
		for(int j = 0; j <= sz[to]; j++)
			dp2[i + j] = // пересчет
	sum += sz[to];
}
```



### доказательство
Ну тут я не силен сори. Но сводится примерно к следующему: 
во-первых, возьмем k = n для облегчения,
теперь посчитаем за сколько пересчет для одной вершины (по вседокоду понятно). sz[to_0] + sz[to_1] * (sz[to_0]) + sz[to_2] * (sz[to_1] + sz[to_0]) и тд.
Если расскрыть получится сумма произведений размеров всех поддеревьев. Так вот, значит сколько раз пара каких-то вершин (v, u) будет посчитана? Ровно один раз: в lca(v, u). Ну вот получается квадрат, а вы что хотели)))
Опять таки нормальное объяснения в разборе примера №2.