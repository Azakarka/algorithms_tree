# Оптимизация Кнута

## Предисловие
Оптимизация Кнута в каком-то смысле прокаченная версия разделяйки (разделяй и властвуй), но и требует немного больше условий. Алгоритм не намного тяжелее, но менее уверсальный, зато асимптотика без log и всяких там рекурсий.

## Постановка задачи
Вся та же задача на разделяйку: есть массив длины n, надо разделить его на K блоков, так чтобы сумма квадратов суммы по блокам была минимальна. 

## Тупняк
Тупняк все такой же. 

dp[k][i] = min(dp[k - 1][j] + sum(j + 1, i) ^ 2) | j < i

## Алгоритм
Введем вспомагательный массив opt

opt[k][i] - тот самый j, который дает минимальное значение для dp[k][i]

В разделяйке мы выяснили, что opt[k][i] <= opt[k][i + 1], и интуитивно понятно, что если мы добавим еще одного чела в конец, то левая граница последнего блока сдвинется.

*Мы поставили ограничение сверху, а что насчет поставить его и снизу!*

Заметим, что если у нас меньше кол-во блоков, на которое мы можем разделить, то левой границе последнего блока не выгодно идти направо, или на математическом языке:

*opt[k - 1][i] <= opt[k][i]*


Итого: opt[k - 1][i] <= opt[k][i] <= opt[k][i + 1]

Тогда давайте просто посчитаем opt[k - 1][i] и opt[k][i + 1], и втупую пересчитаем dp[k][i] в этом промежутке. Потом посмотрим почему это будет быстро.

## КОДе)

Немного о мелочах реализации. Перед тем как мы придем в нужное нам dp[k][i], нам нужно побывать в dp[k - 1][i] и в dp[k][i + 1].

Тогда вопрос: *как правильно задать обход динамики?*

Очень просто на самом деле, просто будет идти по увеличению k и по уменьшению i.

```
for (k = 0...K) {
	for (i = n - 1...0) {
		for (j = opt[k - 1][i]...opt[k][i + 1])
			dp[k][i] = ...пересчет...
			opt[k][i] = ...пересчет...
	}
}
```


## Асимптотика

Понятно, что это будет работать, но почему *быстро*?

Нам по сути нужно посчитать вот такую сумму:

opt[k][i + 1] - opt[k - 1][i] + 1 | по всем k и i

 Разделим для удобства эту сумму на части, а единицу просто уберем и пустим n * K в асимптотику.
 
 Тогда для удобства изобразим наши числа как клеточки в матрице K * N
 
 
 *тогда opt[k][i + 1] по всем k и i будет выглядеть так:*
 
 То есть мы берем все клеточки, кроме n - 1
 ![[таблица база плюс.png]]
 
 
 *а opt[k  - 1][i] соотвественно так:*
 
 ![[таблица база минус.png]]
 
 
 тогда их разность будет выглядеть так:
 
![[таблица база сумма.png]]

заметим, что почти все сократилось, кроме двух столбиков.

разность нам асимптотически не важна, а сумма будет n ^ 2 (каждый k = 0 мы считаем за линию).

Итого:  O(n ^ 2 + n * k)

 


