БПФ - быстрое преобразование Фурье


Во-первых кто знает английский советую глянуть это видео
https://www.youtube.com/watch?v=h7apO7q16V0&ab_channel=Reducible
потому, что он объясняет прям вот с самого низа: зачем, для чего, кто, когда, где. Ставит задачу и по-тихоньку логически объясняет разные штуки. В итоге в конце ты не просто запоминаешь, а понимаешь почему так и что так. +там есть анимация(а у меня нет).


# Идея

## предисловие
Многочлен в информатике обычно представляется в виде списка коэффициентов, от самого маленького до самого большого. 

a[0] + a[1] * x + a[2] * x^2 .... a[n - 1] * x^(n - 1)
- многочлен длины n

Соответсвенно значение в точке можно найти за O(n).

Также можно всем многочленам задать одну длину, так как если у нас размер меньше чем надо, можно просто допихнуть в конец нули, многочлен длины max_n готов.

Также есть теорема, что многочлен максимальной степени n взаимно однозначно задается n + 1 точками. 

## постановка задачи

Имеется два многочлена в коэффициентом представлении длины n, нужно их быстро как-то умножить и вывести мночлен тоже в коэффициентом представлении.


## алгоритм

Сначала небольшая схемка, которая разделит эту часть на еще подчасти.

Значит у нас есть два многочлена длины n, нам нужно вывести их произведение длины 2n. Во-первых, поставим им всем одинаковый размер и больше не будем вспоминать. Теперь все три многочлена размера 2n(потом будет считаться как n).

Теперь интересный факт: если бы наши многочлены были представлены в виде точек, мы бы просто за O(n) перемножили соответственные точки и получили бы новый многочлен тоже в виде точек. 

Тогда какой план: 
1) Перевести многочлены из коэффициентного представления в точечное представление.
2) перемножить
3) Перевести многолчен из точечного представления в коэффициентное.
4) профит

первый шаг как раз и есть БПФ, третий же обратный БПФ. (FFT и IFFT соотвественно). 

### Коэффициенты в числа

Нам нужно в n точках найти значения, как это делать?

Понятно, что можно взять n любых точек, но счет тогда получится за квадрат. Как же ускорить?

Взглянем на простую функцию  f(x) = x ^ 2, к примеру нам надо взять тут 4 точки. Что можно заметить? Мы можем посчитать две точки при x > 0, и взять такие же точки только с минусом, но с такими же значениями, то есть
x = 1 -> f(x) = 1 -> f(-x) = 1
x = 2 -> f(x) = 4 -> f(-x) = 4
Теперь мы считали всего n/2 точек, но нашли значения в n точках из-за парности. 


А что если взять, к примеру, f(x) = x ^ 3? То же самое, только значения будут отрицательными. 
x = 1 -> f(x) = 1 -> f(-x) = -1
x = 2 -> f(x) = 8 -> f(-x) = -8

Представим многочлен f(x) = a[0] + a[1] * x + a[2] * x^2 и тд 

как f(x) = f1(x ^ 2) + x * f2(x ^ 2), 

где f1 содержит в себе коэффициенты при четных степенях, а f2 - при нечетных.

И так как мы берем точки парные +- x1, +- x2, ..., то f1 и f2 нужно будет считать при одинаковых точках. Так как xi^2 = (-xi)^2 (великий вождь). 

Ну вот и все теперь осталось считать f1 и f2 в одинаковых точках, а значение находить по формуле

f(xi) = f1(xi ^ 2) + x * f2(x ^ 2)
f(-xi) = f1(xi ^ 2) - x * f2(x ^ 2)

Вот и все вот и рекурсия вот и весь FFТ, ладно шутка. Тут есть маленький такой прикольчик. Да, мы изначально берем точки парные +- x1 и тд, но при переходе по рекурсии эта парность теряется.

Что же делать? Прибегнуть к комплексным числам! 

Давайте возьмем  f(x) = x ^ 3 + x ^ 2 + x - 1

 и точки +-x1, +- x2
 
тогда что у нас будет?

x1      -x1    x2    -x2
    \    /           \      / 
	x1^2              ?

Как можно заметить на следующем шаге рекурсии точки должны быть парными поэтому ? = -x1 ^ 2 
x1      -x1    x2    -x2
    \    /           \      / 
	x1^2            -x1^2
		\ 				/
			 x1 ^ 4
			
Пусть x1 = 1, тогда 
1      -1        x2    -x2
    \    /           \      / 
	  1            -x1^2
		 \ 			/
			  1
... тогда -x1 ^ 2 = -1, что значит x2 ^ 2 = -1, но какие числа мы можем взять тогда? Правильно x2 = i
1      -1        i         -i
    \    /           \      / 
	  1            		-1
		 \ 			/
			  1
хоба и все заработало.

Тогда как это можно обобщить, как находить корни такие, чтобы в конце осталась единица?

Возьмем w = e ^ (2 * pi * i / n)
тогда нам просто нужно будет посчитать значение многочлена в точках 

[1, w, w ^ 2, w ^ 3, ...., w ^ (n - 1)]

Но почему они будут попарными? 

По формуле Эйлера, что e ^ (i * phi) = cos(phi) + i * sin(phi), можно заметить, что

w[j] и w[j + n/2] парны. Но почему при переходе они тоже будут парны?

Потому, что x[ind] = e ^ (2 * pi * i * ind / n), соответсвенно на каждом шагу рекурсии мы будем брать каждую вторую точку, начиная с первой, или другими словами четные степени. И нетяжело понять, что из-за того, что мы берем каждую вторую парность сохраняются и точки будут также попарны.

Ага ну вот и все. Нам нужно просто написать алгоритм, который считает многочлен в точках [1, w, w ^ 2 ...], где w = e ^ (2 * pi * i / n). И сделаем мы это за nlog.


### перемножение

Ну теперь раз мы можем представить два многочлена в точечном представлении, возьмем и за линию перемножим все точки, из чего получим итоговый многочлен.

...правда до сих пор в точечном виде


### обратный FFT

что ж, здесь начинается самая магия этого прекрасного алгоритма. Чудесные махинации, хитрее чем у Хабы даже. Значит представим для удобства наше уравнение в виде матрицы.

f(x) = a[0] + a[1]  * x ... a[n - 1] * x ^ (n - 1)

тогда

[f(x[0])]			[1, x0, x0^2 ....   x0 ^ (n - 1)]     [a[0]]
[f(x[1])]			[1, x1, x1 ^ 2 ..... 					]	  [a[1]]
[f(x[2])]		=  [											]	  [a[2]]
[f(x[3])]			[											 ]		[a[3]]
[f(x[n-1])]		   [                      x[n-1] ^ (n -1)]		[a[n-1]]


вот так криво-косо я представил перемножение матриц, то есть матрица значений в точках - это матрица коэффициентов, на вон ту страшную матрицу, у которой есть страшное название. Ну не конкретно у нее, а если там x заменить на e ^ ( 2 * pi ... ну понятно да.

Так вот оказалось(так не тяжело посчитать, что (мне капец как лень рисовать матрицу, так что просто скажу). 

матрица значений = 1/n * матрица обратных значений * матрица коэффициентов

Что такое матрица обратных значений? Это та же матрица что сверху, только xi ^ k заменен на xi ^ (-k).

Вот и все. То есть нам достаточно поменять степени с k на -k и вот обратный FFT, не волшебно ли?




## Код

код скатан с emaxx, так как в единственный раз когда я использовал FFT, я скатал его с emaxx.

https://e-maxx.ru/algo/fft_multiply

```
typedef complex<double> base;
 
void fft (vector<base> & a, bool invert) {
	int n = (int) a.size();
	if (n == 1)  return;
 
	vector<base> a0 (n/2),  a1 (n/2);
	for (int i=0, j=0; i<n; i+=2, ++j) {
		a0[j] = a[i];
		a1[j] = a[i+1];
	}
	fft (a0, invert);
	fft (a1, invert);
 
	double ang = 2*PI/n * (invert ? -1 : 1);
	base w (1),  wn (cos(ang), sin(ang));
	for (int i=0; i<n/2; ++i) {
		a[i] = a0[i] + w * a1[i];
		a[i+n/2] = a0[i] - w * a1[i];
		if (invert)
			a[i] /= 2,  a[i+n/2] /= 2;
		w *= wn;
	}
}
```

да, вот так и живем, ладно всем пока, пожалуйста, кто-нибудь допилите страница на этот алгос. 


				
				